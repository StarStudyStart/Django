# 可迭代对象-iterable

> object，能够逐一返回成员项的对象

实现了`__iter__()`方法的对象都可以被成为**可迭代对象**，例如：`List、Tuple、Dict  etc`

# 迭代器

> object，迭代器用来表示一连串数据流的对象

- **迭代器都属于可迭代对象**

- 实现了`__iter__（）`和`__next__（）`方法的对象，可以称之为迭代器

python支持在容器对象中进行迭代，并且允许用户自定义迭代方法（类中定义`__iter__（）`和`__next___（）`方法）

## 1、容器对象实现迭代

容器对象想要实现迭代，必须定义一个方法。而且**一般容器对象都已经内置`__iter__()`方法**

`container.__iter__()`:返回一个迭代器对象

## 2、自定义迭代对象

`__iter__()`:返回迭代对象本身

`__next__()`:返回容器对象的元素

## 3、内置函数`iter(object,[sentinel])`



返回一个含有`__next__()`方法的`iterator`对象

for循环内部其实就是先调用迭代对象的`iter()`方法，进而使用`next()`方法不停地获取迭代器中的元素

- 如果仅有`object`入参，则object对象需要实现`__iter__()`

- 如果`object`和`sentinel`入参同时存在，则要求`object`为可调用的对象。迭代器调用`next`方法的返回值满足`sentinel`值时抛出`StopIteration`异常

第二种情况常用于读取文件时的“块读取器”

```
from functools import partial
with open("file", rb) as f:
	for block in iter(partial(f.read, 64), b''):
			expression_bolck(block)
```

# 生成器

## 生成器

>  能够返回一个迭代器生成器的函数

通常来说生成器指的是*生成器函数*,  ；一般函数中包含`yield`关键字，即可称之为**生成器函数**。

## 生成器迭代器

> 迭代去除生成器中元素的

调用**生成器函数**时返回的对象，内部自动实现`__iter__()`和`__next__()`方法

**特性：**每次执行到`yield`表达式都会暂停，等待下一次调用**生成器迭代器**时，会根据上次的执行位置继续往下执行，也就是`yield`表达式后继续执行。



## 应用场景

### 1、协程 coroutine

生成器常用于协程，协程不像进程需要进程那样锁防止资源锁死。它运行在同一进程中，可以无缝的在各个子程序中跳转运行，最后返回主程序

子程序是协程的特例

### 2、大容量的数据读取

# 二者的区别

1、生成器内部自动生成`__iter__()`、`__next__()`方法

2、生成器常用于大容量数据的读取：因为其特殊的记忆功能，每次for循环仅读取一条数据到内存中。不像List、Set这些迭代对象一样，将大量数据一次性读取到内存中。所以针对大容量数据的处理使用生成器，能够有效的防止内存溢出

3、生成器其实是一种特殊的迭代器，也属于可迭代对象

