<html>
<head>
  <title>Python内存管理机制 - GeaoZhang - 博客园</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="429"/>
<h1>Python内存管理机制 - GeaoZhang - 博客园</h1>

<div>
<span><div><div><h1>Python内存管理机制</h1></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Python的内存管理机制：<a href="https://www.cnblogs.com/geaozhang/p/7111961.html#yinyongjishu" target="_blank">引入计数</a>、<a href="https://www.cnblogs.com/geaozhang/p/7111961.html#lajihuishou" target="_blank">垃圾回收</a>、<a href="https://www.cnblogs.com/geaozhang/p/7111961.html#neicunchijizhi" target="_blank">内存池机制</a></div></blockquote><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">一、变量与对象</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">关系图如下：</div><div><img src="Python内存管理机制 - GeaoZhang - 博客园_files/1113510-20170703162719722-1993553654.png" type="image/png" data-filename="1113510-20170703162719722-1993553654.png" height="270" width="576"/></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">1、变量，通过变量指针引用对象</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　变量指针指向具体对象的内存空间，取对象的值。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">2、对象，类型已知，每个对象都包含一个头部信息（头部信息：类型标识符和引用计数器）</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">注意：</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　变量名没有类型，类型属于对象（因为变量引用对象，所以类型随对象），变量引用什么类型的对象，变量就是什么类型的。</div><div>In [32]: var1=object</div><div>In [33]: var2=var1</div><div><br/></div><div>In [34]: id(var1)</div><div>Out[34]: 139697863383968</div><div><br/></div><div>In [35]: id(var2)</div><div>Out[35]: 139697863383968</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">PS：id()是python的内置函数，用于返回对象的身份，即对象的内存地址。</div><div><img src="Python内存管理机制 - GeaoZhang - 博客园_files/1113510-20170703163116440-978220497.png" type="image/png" data-filename="1113510-20170703163116440-978220497.png" height="229" width="576"/></div><div>In [39]: a=123</div><div>In [40]: b=a</div><div><br/></div><div>In [41]: id(a)</div><div>Out[41]: 23242832</div><div><br/></div><div>In [42]: id(b)</div><div>Out[42]: 23242832</div><div><br/></div><div>In [43]: a=456</div><div><br/></div><div>In [44]: id(a)</div><div>Out[44]: 33166408</div><div><br/></div><div>In [45]: id(b)</div><div>Out[45]: 23242832</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">3、引用所指判断</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　通过is进行引用所指判断，is是用来判断两个引用所指的对象是否相同。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">整数</div><div>In [46]: a=1</div><div>In [47]: b=1</div><div>In [48]: print(a is b)</div><div>True</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">短字符串</div><div><div>In [49]: c=&quot;good&quot;</div><div>In [50]: d=&quot;good&quot;</div><div>In [51]: print(c is d)</div>
True</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">长字符串</div><div>In [52]: e=&quot;very good&quot;</div><div>In [53]: f=&quot;very good&quot;</div><div>In [54]: print(e is f)</div><div>False</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">列表</div><div>In [55]: g=[]</div><div>In [56]: h=[]</div><div>In [57]: print(g is h)</div><div>False</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">由运行结果可知：</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　1、Python缓存了整数和短字符串，因此每个对象在内存中只存有一份，引用所指对象就是相同的，即使使用赋值语句，也只是创造新的引用，而不是对象本身；</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　2、Python没有缓存长字符串、列表及其他对象，可以由多个相同的对象，可以使用赋值语句创建出新的对象。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">二、引用计数</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　在Python中，每个对象都有指向该对象的引用总数---引用计数</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　查看对象的引用计数：sys.getrefcount()</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">1、普通引用</div><div>In [2]: import sys</div><div><br/></div><div>In [3]: a=[1,2,3]</div><div>In [4]: getrefcount(a)</div><div>Out[4]: 2</div><div><br/></div><div>In [5]: b=a</div><div>In [6]: getrefcount(a)</div><div>Out[6]: 3</div><div>In [7]: getrefcount(b)</div><div>Out[7]: 3</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">注意：</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">2、容器对象</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　Python的一个容器对象(比如：表、词典等)，可以包含多个对象。</div><div>In [12]: a=[1,2,3,4,5]</div><div>In [13]: b=a</div><div><br/></div><div>In [14]: a is b</div><div>Out[14]: True</div><div><br/></div><div>In [15]: a[0]=6</div><div>In [16]: a</div><div>Out[16]: [6, 2, 3, 4, 5]</div><div><br/></div><div>In [17]: a is b</div><div>Out[17]: True</div><div><br/></div><div>In [18]: b</div><div>Out[18]: [6, 2, 3, 4, 5]</div><div><img src="Python内存管理机制 - GeaoZhang - 博客园_files/1113510-20170703163942769-1617276581.png" type="image/png" data-filename="1113510-20170703163942769-1617276581.png" height="263" width="576"/></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">由上可见，实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">3、引用计数增加</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　1、对象被创建</div><div><div>In [39]: getrefcount(123)</div><div>Out[39]: 6</div><div><br/></div><div>In [40]: n=123</div><div><br/></div><div>In [41]: getrefcount(123)</div>
Out[41]: 7</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　2、另外的别人被创建</div><div>In [42]: m=n</div><div>In [43]: getrefcount(123)</div><div>Out[43]: 8</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　3、作为容器对象的一个元素</div><div>In [44]: a=[1,12,123]</div><div>In [45]: getrefcount(123)</div><div>Out[45]: 9</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　4、被作为参数传递给函数：foo(x)</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">4、引用计数减少</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　1、对象的别名被显式的销毁</div><div>In [46]: del m</div><div>In [47]: getrefcount(123)</div><div>Out[47]: 8</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　2、对象的一个别名被赋值给其他对象</div><div>In [48]: n=456</div><div>In [49]: getrefcount(123)</div><div>Out[49]: 7</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　3、对象从一个窗口对象中移除，或，窗口对象本身被销毁</div><div>In [50]: a.remove(123)</div><div>In [51]: a</div><div>Out[51]: [1, 12]</div><div><br/></div><div>In [52]: getrefcount(123)</div><div>Out[52]: 6</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　4、一个本地引用离开了它的作用域，比如上面的foo(x)函数结束时，x指向的对象引用减1。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">三、垃圾回收</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　当Python中的对象越来越多，占据越来越大的内存，启动垃圾回收(garbage collection)，将没用的对象清除。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">1、原理</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾。比如某个新建对象，被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。</div><div>In [74]: a=[321,123]</div><div><br/></div><div>In [75]: del a</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">2、解析del</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　del a后，已经没有任何引用指向之前建立的[321,123]，该表引用计数变为0，用户不可能通过任何方式接触或者动用这个对象，当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">3、注意</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　1、垃圾回收时，Python不能进行其它的任务，频繁的垃圾回收将大大降低Python的工作效率；</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　2、Python只会在特定条件下，自动启动垃圾回收（垃圾对象少就没必要回收）</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　3、当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</div><div>In [93]: import gc</div><div><br/></div><div>In [94]: gc.get_threshold()　　#gc模块中查看阈值的方法</div><div>Out[94]: (700, 10, 10)</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">阈值分析：</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　700即是垃圾回收启动的阈值；</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收；</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">当然也是可以手动启动垃圾回收：</div><div>In [95]: gc.collect() #手动启动垃圾回收</div><div>Out[95]: 2</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">4、何为分代回收</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　Python将所有的对象分为0，1，2三代；</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　所有的新建对象都是0代对象；</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">四、内存池机制</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　Python中有分为大内存和小内存：（256K为界限分大小内存）</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">1、大内存使用malloc进行分配</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">2、小内存使用内存池进行分配</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">3、Python的内存池(金字塔)</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　第3层：最上层，用户对Python对象的直接操作</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　第1层和第2层：内存池，有Python的接口函数PyMem_Malloc实现-----若请求分配的内存在1~256字节之间就使用内存池管理系统进行分配，调用malloc函数分配内存，但是每次只会分配一块大小为256K的大块内存，不会调用free函数释放内存，将该内存块留在内存池中以便下次使用。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　第0层：大内存-----若请求分配的内存大于256K，malloc函数分配内存，free函数释放内存。</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">　　第-1，-2层：操作系统进行操作</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"> </div><div><img src="Python内存管理机制 - GeaoZhang - 博客园_files/1113510-20170703164946409-1883256382.png" type="image/png" data-filename="1113510-20170703164946409-1883256382.png" height="337" width="576"/></div></div><div><br/></div></span>
</div></body></html> 