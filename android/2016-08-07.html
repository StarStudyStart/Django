<html>
<head>
  <title>2016-08-07</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="729"/>
<h1>2016-08-07</h1>

<div>
<span><div><span style="font-size: 15px;">总结：service中有两种启动方式，startService（activity向service传输数据）和bindService (service向activity返回数据)</span></div><div>           <span style="font-size: 15px;">前台任务可以长时间的运行而不会因为系统内存不足而被kill，后台定时任务通过AlarmManager对象可以每隔一段时间发送一次广播，重新启动一次该任务，但不能保证时间段之外该实例是否被销毁；</span></div><div>          <span style="font-size: 15px;">android中的四大组件基本上都要自己继承实例化，并且都要在Manifest中手动注册；</span></div><div><span style="color: rgb(255, 0, 0);">   </span> <span style="font-size: 15px;"> 1、startService </span></div><div><span style="font-size: 15px;">               直接实例化一个Intent对象，传入显式意图，也可以携带数据，最后调用startService（intent）；</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="font-size: 15px;">               Intent startIntent = new Intent( this, MyService. class);</span></div><div><span style="font-size: 15px;">               startService(startIntent);</span></div></div><div><span style="font-size: 15px;">                    调用stopService终止服务；</span></div><div><span style="font-size: 15px;">     2、bindservice</span></div><div><span style="font-size: 15px;">               首先要实现ServiceConnection这个接口中的所有方法；</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="font-size: 15px;">private ServiceConnection conn = new ServiceConnection() {</span></div><div><br/></div><div><span style="font-size: 15px;">           @Override</span></div><div><span style="font-size: 15px;">           public void onServiceDisconnected(ComponentName name) {</span></div><div><span style="font-size: 15px;">                // TODO Auto-generated method stub</span></div><div><br/></div><div><span style="font-size: 15px;">          }</span></div><div><br/></div><div><span style="font-size: 15px;">           @Override</span></div><div><span style="font-size: 15px;">           public void onServiceConnected(ComponentName name, IBinder service) {</span></div><div><span style="font-size: 15px;">                // TODO Auto-generated method stub</span></div><div><span style="font-size: 15px;">                downBinder = (DownBinder) service;</span></div><div><span style="font-size: 15px;">                downBinder.startDown();</span></div><div><span style="font-size: 15px;">                downBinder.displayProgress();</span></div><div><span style="font-size: 15px;">          }</span></div><div><span style="font-size: 15px;">     };</span></div></div><div><span style="font-size: 15px;">                     然后直接利用bindService绑定，第三个参数Flag表示绑定服务时的操作；</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font-size: 15px;">               Intent bindIntent = new Intent( this, MyService.class );</span></div><div><span style="font-size: 15px;">               bindService(bindIntent, conn, BIND_AUTO_CREATE );</span></div></div><div><span style="font-size: 15px;">     3、前台启动服务</span></div><div><span style="font-size: 15px;">          在service的onCreate()方法中，创建一个通知对象，不必创建通知的管理对象来显示该对象的属性，直接调用startForeground（notification）即可显示；这样在服务创建的同时就会创建一个前台任务，不停止任务的话，这个前台任务就会一直运行；</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="font-size: 15px;">Notification notification = new Notification(R.drawable. ic_launcher ,</span></div><div><span style="font-size: 15px;">                     &quot;Notification comes&quot; , System.currentTimeMillis()) ;</span></div><div><span style="font-size: 15px;">          Intent notificationIntent = new Intent( this, MainActivity.class );</span></div><div><span style="font-size: 15px;">           // Retrieve a PendingIntent that will start a new activity</span></div><div><span style="font-size: 15px;">          PendingIntent pi = PendingIntent. getActivity( this, 0,</span></div><div><span style="font-size: 15px;">                    notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT );</span></div><div><span style="font-size: 15px;">          notification. setLatestEventInfo( this , &quot;this is content&quot;,</span></div><div><span style="font-size: 15px;">                     &quot;this is Title&quot; , pi);</span></div><div><span style="font-size: 15px;">          startForeground(1, notification);</span></div></div><div><span style="font-size: 15px;">     4、启动定时的后台服务</span></div><div><span style="font-size: 15px;">          首先在Service的onStartCommand中获取AlarmManager对象</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="font-size: 15px;">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE );</span></div></div><div><span style="font-size: 15px;">     其次直接调用manager.set(xx1,xx2,xx3)方法</span></div><div><span style="font-size: 15px;">     第一个参数表示定时任务的触发时间从什么时候算起，</span></div><div><span style="font-size: 15px;">     第二个参数表示触发的时间点，</span></div><div><span style="font-size: 15px;">     第三个参数传入一个PendingIntent能够在指定的时间点发送自定义广播</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="font-size: 15px;">int anHour = 60 * 60 * 1000;</span></div><div><span style="font-size: 15px;">           // long triggerAtTime = System.currentTimeMillis() + anHour;</span></div><div><span style="font-size: 15px;">           long triggerAtTime = SystemClock. elapsedRealtime() + anHour;</span></div><div><span style="font-size: 15px;">          Intent i = new Intent(LongRunningService. this, AlarmReceiver.class );</span></div><div><span style="font-size: 15px;">          PendingIntent pi = PendingIntent.getBroadcast(LongRunningService. this,</span></div><div><span style="font-size: 15px;">                    0, i, 0);</span></div><div><span style="font-size: 15px;">          manager.setExact(AlarmManager. ELAPSED_REALTIME_WAKEUP , triggerAtTime,</span></div><div><span style="font-size: 15px;">                    pi);</span></div></div><div><span style="font-size: 15px;">          然后在自定义广播中再次启动Service；</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="font-size: 15px;">@Override</span></div><div><span style="font-size: 15px;">      public void onReceive(Context context, Intent intent) {</span></div><div><span style="font-size: 15px;">           // TODO Auto-generated method stub</span></div><div><span style="font-size: 15px;">          Intent i = new Intent(context,LongRunningService.class );</span></div><div><span style="font-size: 15px;">          context. startService(i);</span></div><div><span style="font-size: 15px;">     }</span></div></div><div><span style="font-size: 15px;">     最后在activity中首先启动service，程序运行后系统会首先调用onstartCommand方法，实现其中的代码块，</span></div><div><span style="font-size: 15px;">      然后实现定时AlarmManager.set()，一段时间后发送广播；</span></div><div><span style="font-size: 15px;">     广播接收器接收后，再次启动service</span></div><div><span style="font-size: 15px;">     这样就可以实现每隔一段时间就会启动一次service，实现一次onStartCommand中的代码，除非停止广播</span></div><div>    <span style="font-size: 15px;"> 4、IntentService</span></div><div><span style="font-size: 15px;">          intentservice可以实现在服务中自动新开一个线程，实现具体的逻辑，在逻辑执行结束后自动结束当前任务；</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font-size: 15px;">public class MyIntentService extends IntentService {</span></div><div><span style="font-size: 15px;">      private final static String TAG = &quot;MyIntentService&quot; ;</span></div><div><br/></div><div><span style="font-size: 15px;">      public MyIntentService() {</span></div><div><span style="font-size: 15px;">           super( &quot;MyIntentService&quot; );</span></div><div><span style="font-size: 15px;">     }</span></div><div><br/></div><div><span style="font-size: 15px;">      @Override</span></div><div><span style="font-size: 15px;">      protected void onHandleIntent(Intent intent) {</span></div><div><span style="font-size: 15px;">           // TODO Auto-generated method stub</span></div><div><span style="font-size: 15px;">          Log. d( TAG, &quot;Thread id is &quot; + Thread.currentThread().getId());</span></div><div><span style="font-size: 15px;">     }</span></div><div><br/></div><div><span style="font-size: 15px;">      @Override</span></div><div><span style="font-size: 15px;">      public void onDestroy() {</span></div><div><span style="font-size: 15px;">           // TODO Auto-generated method stub</span></div><div><span style="font-size: 15px;">           super.onDestroy();</span></div><div><span style="font-size: 15px;">          Log. d( TAG, &quot;IntentService is onDestroy&quot;);</span></div><div><span style="font-size: 15px;">     }</span></div><div><span style="font-size: 15px;">}</span></div></div><div><br/></div></span>
</div></body></html> 