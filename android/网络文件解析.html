<html>
<head>
  <title>网络文件解析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="727"/>
<h1>网络文件解析</h1>

<div>
<span><div>总结：xml文件的解析方式pull、SAX、DOM；前面两种解析方式基本都要先实例化对应的工厂，在从工厂对象中实例XmlReader、Xmlpullpraser；</div><div>          json的解析方式，JSONArray——&gt;JSONObject            GSON——&gt;google的jar包，可以直接json数据解析成某个对象</div><div>     1、pull方式</div><div>          ①首先要实例化工厂类，再从工厂类中取得xmlPullPraser类的实例化对象；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>               XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</div><div>               XmlPullParser praser = factory.newPullParser();</div></div><div>     </div><div>          ② 设置解析的数据源，获取当前的事件（标签）类型； --------将要解析的数据转化成可读的字符流，作为参数传入setInput();调用这个方法的同时，自动初始化事件类型event type为<font color="#3F7F5F" face="Courier New"><span style="font-size:12pt; background:#e8f2fe">START_DOCUMENT</span></font>；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>               praser.setInput( new StringReader(xmlData));</div><div>                int eventType = praser.getEventType();</div></div><div>          ③初始化数据，while循环判断是否为文档的结尾标签，不断的移动解析对象到下一个事件（标签）直到结束；</div><div>                                                  在while循环内部首先获取当前标签的名称：即节点——&gt;String nodeName = praser.get</div><div>                                                  加一个switch判断当前标签的类型，如果是开始标签的名称则判断是否与指定的字符串匹配，然后取出该标签所对应的内容praser.getNext();</div><div>                                                  最后获取下一个标签的类型，并且复制给event的类型；eventType = praser.next();</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>              while (eventType != XmlPullParser. END_DOCUMENT) {</div><div>                    String nodeName = praser.getName();</div><div>                     switch (eventType) {</div><div>                     case XmlPullParser. START_TAG:</div><div>                          if ( &quot;id&quot;.equals(nodeName)) {</div><div>                              id = praser.nextText();</div><div>                         } else if (&quot;mp3.name&quot; .equals(nodeName)) {</div><div>                              mp3_name = praser.nextText();</div><div>                         } else if (&quot;mp3.lrc&quot; .equals(nodeName)) {</div><div>                              mp3_lrc = praser.nextText();</div><div>                         }</div><div><br/></div><div>                          break;</div><div>                     case XmlPullParser. END_TAG:</div><div>                          if ( &quot;resource&quot;.equals(nodeName)) {</div><div>                              Log. d( TAG, &quot;mp3 id is &quot; + id);</div><div>                              Log. d( TAG, &quot;mp3 name is &quot; + mp3_name);</div><div>                              Log. d( TAG, &quot;mp3 lrc is &quot; + mp3_lrc);</div><div>                         }</div><div><br/></div><div>                          break;</div><div><br/></div><div>                     default:</div><div>                          break;</div><div>                    }</div><div>                     // 移动到下一个标签解析</div><div>                    eventType = praser.next();</div><div>               }</div><div>         </div></div><div>     2、SAX解析：SAX解析的用法比pull更复杂但是予以更明确。首先需要首先自定义一个内容处理对象ContentHandler继承DefaultHandler；</div><div>               ① 重写父类的</div><div><i><font face="Courier New"><span style="font-size:12pt; background:#e8f2fe">               startDocument()方法：开始xml解析时调用；</span></font></i></div><div><span style="font-size: 16px;"><i><span style="font-family: 'Courier New';"><span style="background-color: rgb(232, 242, 254);">               </span></span><font face="Courier New"><span style="background-color: rgb(212, 212, 212); background-position: initial initial; background-repeat: initial initial;">endDocument</span><span style="background-color: rgb(232, 242, 254); background-position: initial initial; background-repeat: initial initial;">()方法：结束</span></font><font face="Courier New"><span style="background-color: rgb(232, 242, 254); background-position: initial initial; background-repeat: initial initial;">xml解析时调用；</span></font></i></span></div><div><span style="font-size: 16px;"><i><span style="font-family: 'Courier New';"><span style="background-color: rgb(232, 242, 254);">               </span></span><font face="Courier New"><span style="background-color: rgb(212, 212, 212); background-position: initial initial; background-repeat: initial initial;">startElement()：开始解析某个节点时调用，在这个方法中；</span></font></i></span></div><div><span style="font-size: 16px;"><i><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);">               </span></span><font face="Courier New"><span style="background-color: rgb(212, 212, 212); background-position: initial initial; background-repeat: initial initial;">endElement()：</span></font><font face="Courier New"><span style="background-color: rgb(212, 212, 212); background-position: initial initial; background-repeat: initial initial;">某个节点节点解析完成时调用；</span></font></i></span></div><div><span style="font-size: 16px;"><i><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);">               </span></span></i><font face="Courier New"><span style="background-color: rgb(212, 212, 212); background-position: initial initial; background-repeat: initial initial;">characters()：再开始节点解析和结束节点解析时都会调用；</span></font></span></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);">         <br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);"><br/></span></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div style="margin-left:40px;">public class MyHandler extends DefaultHandler {</div><div style="margin-left:40px;">      private final static String TAG = &quot;SAX_PRASE&quot; ;</div><div style="margin-left:40px;">      private String nodeName = null;</div><div style="margin-left:40px;">     StringBuilder id;</div><div style="margin-left:40px;">     StringBuilder name;</div><div style="margin-left:40px;">     StringBuilder version;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">      @Override</div><div style="margin-left:40px;">      public void startDocument() throws SAXException {</div><div style="margin-left:40px;">           // TODO Auto-generated method stub</div><div style="margin-left:40px;">           id = new StringBuilder();</div><div style="margin-left:40px;">           name = new StringBuilder();</div><div style="margin-left:40px;">           version = new StringBuilder();</div><div style="margin-left:40px;">     }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">      @Override</div><div style="margin-left:40px;">      public void endDocument() throws SAXException {</div><div style="margin-left:40px;">           // TODO Auto-generated method stub</div><div style="margin-left:40px;">     }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">      @Override</div><div style="margin-left:40px;">      public void startElement(String uri, String localName, String qName,</div><div style="margin-left:40px;">               Attributes attributes) throws SAXException {</div><div style="margin-left:40px;">           // TODO Auto-generated method stub</div><div style="margin-left:40px;">          Log. d( &quot;SAX_PRASE&quot;, &quot;123456&quot;);</div><div style="margin-left:40px;">           nodeName = localName;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">     }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">      @Override</div><div style="margin-left:40px;">      public void endElement(String uri, String localName, String qName)</div><div style="margin-left:40px;">                throws SAXException {</div><div style="margin-left:40px;">           nodeName = qName;</div><div style="margin-left:40px;">           if ( &quot;app&quot;.equals(localName)) {</div><div style="margin-left:40px;">               Log. d( TAG, id.toString().trim());</div><div style="margin-left:40px;">               Log. d( TAG, name.toString().trim());</div><div style="margin-left:40px;">               Log. d( TAG, version.toString().trim());</div><div style="margin-left:40px;">//             清空缓存</div><div style="margin-left:40px;">                id.setLength(0);</div><div style="margin-left:40px;">                name.setLength(0);</div><div style="margin-left:40px;">                version.setLength(0);</div><div style="margin-left:40px;">          }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">     }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">      @Override</div><div style="margin-left:40px;">      public void characters (char [] ch, int start, int length)</div><div style="margin-left:40px;">                throws SAXException {</div><div style="margin-left:40px;">           if ( &quot;id&quot;.equals( nodeName)) {</div><div style="margin-left:40px;">                id = id.append(ch, start, length);</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">          } else if ( &quot;name&quot;.equals( nodeName)) {</div><div style="margin-left:40px;">                name = name.append(ch, start, length);</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">          } else if ( &quot;version&quot;.equals( nodeName)) {</div><div style="margin-left:40px;">                version = version.append(ch, start, length);</div><div style="margin-left:40px;">          }</div><div style="margin-left:40px;">     }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">}</div></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);">     然后再主程序中调用即可：</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);"><br/></span></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>               SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();</div><div>               XMLReader xmlReader = saxParserFactory.newSAXParser()</div><div>                         .getXMLReader();</div><div>               MyHandler contentHandler = new MyHandler();</div><div>               xmlReader.setContentHandler(contentHandler);</div><div>               xmlReader.parse( new InputSource( new StringReader(xmlData)));</div></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';"><span style="background-color: rgb(212, 212, 212);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';">3、 JSON数据的体积小，可以更省流量，但是语义性较差；</span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';">   JSON解析也相对较简单，就是将得到的数据出入到JSONArray对象的构造方法中，然后利用for循环依次取出各个JSONObject对象，并通过getString（）；取出具体点的节点内容；</span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';"><br/></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>                JSONArray jsonArray = new JSONArray(jsonData);</div><div>                for ( int i = 0; i &lt; jsonArray.length(); i++) {</div><div>                    JSONObject jsonObject = jsonArray.getJSONObject(i);</div><div>                    String id = jsonObject.getString( &quot;id&quot;);</div><div>                    String version = jsonObject.getString(&quot;version&quot; );</div><div>                    String name = jsonObject.getString(&quot;name&quot; );</div><div>                    Log. d( TAG, &quot;the app id is &quot; + id);</div><div>                    Log. d( TAG, &quot;the app name is &quot; + name);</div><div>                    Log. d( TAG, &quot;the app version is &quot; + version);</div><div>               }</div><div>          </div></div><div><span style="font-size: 16px;"><span style="font-family: 'Courier New';">4、</span></span>GSON——&gt;google的jar包，可以直接json数据解析成某个自定义对象</div><div>          实例化GSON对象，然后传入json数据， 利用TypeToken类获得所要解析成的对象的类型</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>          Gson gson = new Gson();</div><div>           // 利用TypeToken將期望解析成的數據類型傳入到fromJson()方法中</div><div>          List&lt;App&gt; apps = gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;() {</div><div>          }.getType());</div><div>     }</div></div><div>5、实现网络请求方法的复用，在静态方法中开启新线程来发送http请求，但是返回的数据不能通过静态方法直接返回，因为服务器还没来得及返回数据时，sendRequest（）已经之行结束了；</div><div>          利用java的回调机制可以将服务器返回的数据返回；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div style="margin-left:40px;">public class HttpUtil {</div><div style="margin-left:40px;">      public static void sendRequest( final String address,</div><div style="margin-left:40px;">                final HttpCallBackListener httpListener) {</div><div style="margin-left:40px;">           new Thread( new Runnable() {</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">                @Override</div><div style="margin-left:40px;">                public void run() {</div><div style="margin-left:40px;">                    HttpClient httpClient = new DefaultHttpClient();</div><div style="margin-left:40px;">                    HttpGet httpGet = new HttpGet(address);</div><div style="margin-left:40px;">                     try {</div><div style="margin-left:40px;">                          // HttpPost httpPost = new HttpPost(&quot;http://www.baidu.com&quot;);</div><div style="margin-left:40px;">                          // List&lt;NameValuePair&gt; parameters = new</div><div style="margin-left:40px;">                          // ArrayList&lt;NameValuePair&gt;();</div><div style="margin-left:40px;">                          // parameters.add(new BasicNameValuePair(&quot;username&quot;,</div><div style="margin-left:40px;">                          // &quot;admin &quot;));</div><div style="margin-left:40px;">                          // parameters.add(new BasicNameValuePair(&quot;password&quot;,</div><div style="margin-left:40px;">                          // &quot;123456&quot;));</div><div style="margin-left:40px;">                          // UrlEncodedFormEntity postEntity = new</div><div style="margin-left:40px;">                          // UrlEncodedFormEntity(parameters,&quot;utf-8&quot;);</div><div style="margin-left:40px;">                          // httpPost.setEntity(postEntity);</div><div style="margin-left:40px;">                         HttpResponse httpResponse = httpClient.execute(httpGet);</div><div style="margin-left:40px;">                          if (httpResponse.getStatusLine().getStatusCode() == 200) {</div><div style="margin-left:40px;">                              HttpEntity entity = httpResponse.getEntity();</div><div style="margin-left:40px;">                              String content = EntityUtils.toString(entity);</div><div style="margin-left:40px;">                              httpListener.OnFinish(content);</div><div style="margin-left:40px;">                         }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">                    } catch (Exception e) {</div><div style="margin-left:40px;">                          // TODO Auto-generated catch block</div><div style="margin-left:40px;">                         httpListener.onError(e);</div><div style="margin-left:40px;">                    }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">               }</div><div style="margin-left:40px;">          }).start();</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">     }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">}</div></div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div style="margin-left:40px;">                    String address = &quot;http://www.baidu.com&quot;;</div><div style="margin-left:40px;">                     // 使用静态方法的方式，调用网络请求；然后在回调接口中可以操作返回的数据</div><div style="margin-left:40px;">                    HttpUtil. sendRequest(address, new HttpCallBackListener() {</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">                          @Override</div><div style="margin-left:40px;">                          public void onError(Exception e) {</div><div style="margin-left:40px;">                               // TODO Auto-generated method stub</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">                         }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">                          @Override</div><div style="margin-left:40px;">                          public void OnFinish(String reponse) {</div><div style="margin-left:40px;">                               // TODO Auto-generated method stub</div><div style="margin-left:40px;">                              Message msg = handler .obtainMessage();</div><div style="margin-left:40px;">                              msg. what = SHOW_RESPONSE;</div><div style="margin-left:40px;">                              msg. obj = reponse;</div><div style="margin-left:40px;">                               handler.sendMessage(msg);</div><div style="margin-left:40px;">                         }</div><div style="margin-left:40px;">                    });</div></div><div><span style="color: rgb(255, 0, 0);"><br/></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 19px;">遗留问题：</span></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 19px;">          java的回调（需要熟悉）</span></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 19px;">          dom解析方式</span></span></div><div><span style="color: rgb(229, 0, 255);"><span style="font-size: 21px;">感想：今天的总结很蛋疼，耗费了将近两个小时；</span></span></div></span>
</div></body></html> 