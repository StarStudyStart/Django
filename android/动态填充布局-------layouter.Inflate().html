<html>
<head>
  <title>动态填充布局-------layouter.Inflate()</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="824"/>
<h1>动态填充布局-------layouter.Inflate()</h1>

<div>
<span><div>1、首先获取LayouterInflater对象两种方式：</div><div>               ① LayouterInflater inflater = LayouterInflater.From(context);</div><div>               ② LayouterInflater inflater = context.getSystemService();</div><div>          其实最终调用的都是第二种方法。</div><div><br/></div><div>2、其次 inflater.inflate()方法，返回的是一个view对象；inflate(<span style="font-family: 宋体;"><span style="color:#000080;font-weight:bold;">int </span><span style="background-color:#e4e4ff;">resource，</span>ViewGroup root, <span style="color:#000080;font-weight:bold;">boolean </span><span style="background-color:#e4e4ff;">attachToRoot</span></span>) <span style="color: rgb(85, 85, 85); font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); display: inline !important; float: none;">三个参数的方法重载，</span>但最终调用的是下面的方法。</div><div>          </div><div style="box-sizing: border-box;"><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {</div><div>    synchronized (mConstructorArgs) {</div><div>        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</div><div><br/></div><div>        final Context inflaterContext = mContext;</div><div>        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div>        Context lastContext = (Context) mConstructorArgs[0];</div><div>        mConstructorArgs[0] = inflaterContext;</div><div>        View result = root;</div><div><br/></div><div>        try {</div><div>            // Look for the root node.</div><div>            int type;</div><div>            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div>                    type != XmlPullParser.END_DOCUMENT) {</div><div>                // Empty</div><div>            }</div><div><br/></div><div>            if (type != XmlPullParser.START_TAG) {</div><div>                throw new InflateException(parser.getPositionDescription()</div><div>                        + &quot;: No start tag found!&quot;);</div><div>            }</div><div><br/></div><div>            final String name = parser.getName();</div><div><br/></div><div>            if (DEBUG) {</div><div>                System.out.println(&quot;**************************&quot;);</div><div>                System.out.println(&quot;Creating root view: &quot;</div><div>                        + name);</div><div>                System.out.println(&quot;**************************&quot;);</div><div>            }</div><div><br/></div><div>            if (TAG_MERGE.equals(name)) {</div><div>                if (root == null || !attachToRoot) {</div><div>                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div>                            + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div>                }</div><div><br/></div><div>                rInflate(parser, root, inflaterContext, attrs, false);</div><div>            } else {</div><div>                // Temp is the root view that was found in the xml</div><div>                <span style="color: rgb(227, 0, 0);">final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span></div><div><br/></div><div>                ViewGroup.LayoutParams params = null;</div><div><br/></div><div>                if (root != null) {</div><div>                    if (DEBUG) {</div><div>                        System.out.println(&quot;Creating params from root: &quot; +</div><div>                                root);</div><div>                    }</div><div>                    // Create layout params that match root, if supplied</div><div>                    <span style="color: rgb(229, 0, 255);">params = root.generateLayoutParams(attrs);</span></div><div>                    if (!attachToRoot) {</div><div>                        // Set the layout params for temp if we are not</div><div>                        // attaching. (If we are, we use addView, below)</div><div>                        <span style="color: rgb(235, 0, 115);">temp.setLayoutParams(params);</span></div><div>                    }</div><div>                }</div><div><br/></div><div>                if (DEBUG) {</div><div>                    System.out.println(&quot;-----&gt; start inflating children&quot;);</div><div>                }</div><div><br/></div><div>                // Inflate all children under temp against its context.</div><div>                <span style="color: rgb(247, 255, 0);"><span style="color: rgb(77, 206, 29);">rInflateChildren(parser, temp, attrs, true);</span></span></div><div><br/></div><div>                if (DEBUG) {</div><div>                    System.out.println(&quot;-----&gt; done inflating children&quot;);</div><div>                }</div><div><br/></div><div>                // We are supposed to attach all the views we found (int temp)</div><div>                // to root. Do that now.</div><div>                if (root != null &amp;&amp; attachToRoot) {</div><div>                    root.addView(temp, params);</div><div>                }</div><div><br/></div><div>                // Decide whether to return the root that was passed in or the</div><div>                // top view found in xml.</div><div>                if (root == null || !attachToRoot) {</div><div>                    result = temp;</div><div>                }</div><div>            }</div><div><br/></div><div>        } catch (XmlPullParserException e) {</div><div>            final InflateException ie = new InflateException(e.getMessage(), e);</div><div>            ie.setStackTrace(EMPTY_STACK_TRACE);</div><div>            throw ie;</div><div>        } catch (Exception e) {</div><div>            final InflateException ie = new InflateException(parser.getPositionDescription()</div><div>                    + &quot;: &quot; + e.getMessage(), e);</div><div>            ie.setStackTrace(EMPTY_STACK_TRACE);</div><div>            throw ie;</div><div>        } finally {</div><div>            // Don't retain static reference on context.</div><div>            mConstructorArgs[0] = lastContext;</div><div>            mConstructorArgs[1] = null;</div><div><br/></div><div>            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div>        }</div><div><br/></div><div>        return result;</div><div>    }</div><div>}<br/><br/></div></div><div><br/></div><div>          这个方法最终返回的是一个view视图。采用pull解析方式，来解析布局文件的根布局， 红色代码行中，<span style="color: rgb(85, 85, 85); font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">createViewFromTag()这个方法，并把节点名和参数传了进去。看到这个方法名，我们就应该能猜到，它是用于根据节点名来创建View对象的。确实如此，在<span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">createViewFromTag()方法的内部又会去调用createView()方法，然后使用反射的方式创建出View的实例并返回。</span></span><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">当然，这里只是创建出了一个根布局的实例而已，接下来在绿色的代码行，调用</span><span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">rInflate()方法来循环遍历这个根布局下的子元素，代码如下所示：</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Consolas, 'Courier New', Courier, mono, serif;"><span style="color: rgb(85, 85, 85);"><br/></span></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>- private void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs)</div><div>-         throws XmlPullParserException, IOException {</div><div>-     final int depth = parser.getDepth();</div><div>-     int type;</div><div>-     while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div>-             parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {</div><div>-         if (type != XmlPullParser.START_TAG) {</div><div>-             continue;</div><div>-         }</div><div>-         final String name = parser.getName();</div><div>-         if (TAG_REQUEST_FOCUS.equals(name)) {</div><div>-             parseRequestFocus(parser, parent);</div><div>-         } else if (TAG_INCLUDE.equals(name)) {</div><div>-             if (parser.getDepth() == 0) {</div><div>-                 throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div>-             }</div><div>-             parseInclude(parser, parent, attrs);</div><div>-         } else if (TAG_MERGE.equals(name)) {</div><div>-             throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div>-         } else {</div><div>-            <span style="color: rgb(173, 0, 0);"> final View view = createViewFromTag(name, attrs);</span></div><div>-             final ViewGroup viewGroup = (ViewGroup) parent;</div><div>-             final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div>-            <span style="color: rgb(227, 0, 0);"> rInflate(parser, view, attrs);</span></div><div>-             viewGroup.addView(view, params);</div><div>-         }</div><div>-     }</div><div>-     parent.onFinishInflate();</div><div>- }</div></div><div><span style="font-size: 16px;"><span style="font-family: Consolas, 'Courier New', Courier, mono, serif;"><span style="color: rgb(85, 85, 85);"><br/></span></span></span></div><div><div style="margin: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: 'microsoft yahei'; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 16px;"><div>可以看到，深红色代码同样是<span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">createViewFromTag()方法来创建View的实例，递归调用<span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">rInflate()方法来查找这个View下的子元素，每次递归完成后则将这个View添加到父布局当中。</span></span></div></div><p style="margin: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;"><span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;"><br/></span></span></p><div style="margin: 0px; padding: 0px; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif;">这样的话，把整个布局文件都解析完成后就形成了一个完整的DOM结构，最终会把最顶层的根布局返回，至此inflate()过程全部结束。</span></span></span></div><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: Consolas, 'Courier New', Courier, mono, serif;"><br/></span></span></span></div><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">这里的三个参数所代表的意思：</span></span></span></div><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">           int    recourseId：所要加载布局的Id，创建一个解析器会把该id对应的xml文件，放进解析器中等待解析；</span></span></span></div><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">          View  root： 包裹所要加载布局的外层布局。</span></span></span> <span style="color: rgb(85, 85, 85); font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); display: inline !important; float: none;">会给加载的布局文件指定一个父布局，即root。</span></div><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">          boolean attachToRoot：是否返回父布局（root）；</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">inflate(R.id.xxx,null);  返回temp，即所要加载的布局xxx，但是不会正常显示当前布局的参数（</span></span></span><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">没有设置</span></span><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">recourse</span></span></span>V<span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">iew的width和height参数</span></span></span> ，自动获取父布局的参数填充<span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">）；</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">inflate(R.id.xxx,root，false)  </span></span></span><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">返回temp，即所要加载的布局xxx，会正常显示当前布局的参数；</span></span></span></div><div><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">inflate(R.id.xxx,root)  相当于 </span></span><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">inflate(R.id.xxx,root，true)  返回root，不会显示</span><span style="font-family: 'microsoft yahei';">recourse</span></span></span>V<span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">iew的width和height参数；</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">除了这种方法inflate(R.id.xxx,root，false)会正常显示，</span></span></span><span style="color: rgb(85, 85, 85);"><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';">recourse</span></span></span>V<span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">iew的根布局的参数</span></span></span><span style="font-size: 16px;"><span style="font-family: 'microsoft yahei';"><span style="color: rgb(85, 85, 85);">。</span></span></span></div></div></div><div><br/></div></div></span>
</div></body></html> 